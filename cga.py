#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Analyze chess games against a chess engines to see de deviation.
Example::
    $ cga.py games.pgn -e SF8.exe
"""
import os
import sys
import argparse
import logging
import time
import re
import chess.pgn
import chess.uci

__author__ = "Carlos Alamo"
__email__ = "my@email.com"
__date__ = "2017-02-07"
__version__ = "0.01"


class Move:
    """
    Class to store move information.

    :var self.move: Move done
    :vartype self.move: str
    :var self.best_move: Best move according the engine
    :vartype self.best_move: str
    :var self.cp: Centipawns of the move
    :vartype self.cp: int
    :var self.bm_cp: Centipawns of the best move
    :vartype self.bm_cp: int
    :var self.cp_diff: Difference between the move and the best move
    :vartype self.cp_diff: int
    :var self.best_move_position: Position of the move done in the list of
                                  MultiPV generated by the engine
    :vartype self.best_move_position: int
    """
    def __init__(self, move='', cp=0, bm='', bm_cp=0, bmp=0):
        self.move = move
        self.cp = cp
        self.best_move = bm
        self.bm_cp = bm_cp
        self.cp_diff = self.bm_cp - self.cp
        self.best_move_position = bmp

    def __str__(self):
        return '{:5} {{{:12}cp={:<+5}diff={:<+5}pos={:<3}}}'.\
                        format(self.move,
                               self.best_move,
                               self.bm_cp,
                               self.cp_diff,
                               self.best_move_position
                              )


class Player:
    """
    Player class with name, victories, defeats and draws.

    :var self.white_games: All the games of the player with white pieces
    :vartype self.white_games: list(Games)
    :var self.black_games: All the games of the player with black pieces
    :vartype self.black_games: list(Games)
    :var self.opponents:  Opponents of this player
    :vartype self.opponents: list[Player]
    :var self.name: Player's name
    :vartype self.name: str
    """

    def __init__(self, players_name):
        """
        :arg players_name: Player's name
        :type players_name: str
        """
        self.white_games = []
        self.black_games = []
        self.opponents = []
        self.name = players_name


class Engine:
    """
        Engine use for the analysis.
    """

    def __init__(self, path):
        """
            Check that the engine executable exists and start it
        """
        if not os.path.isfile(path):
            logger.error('Engine {} does not exists.'.format(path))
            sys.exit(1)
        self.engine = chess.uci.popen_engine(path)
        self.engine.uci()
        self.name = self.engine.name
        self.multi_pv = self.engine.options['MultiPV'].default
        self._set_multi_pv()

    def _set_multi_pv(self):
        """
        Check if the option MultiPV exisits and set it to the maximum allowed
        by the engine.
        """
        if 'MultiPV' in self.engine.options.keys():
            try:
                max_multi_pv = self.engine.options['MultiPV'].max
            except:
                logger.warning('Not able to get maximum MultiPV.')
            if self.engine.options['MultiPV'].max > 1:
                self.engine.setoption({'MultiPV':max_multi_pv})
                logger.debug('Set MultiPV to: {}'.format(max_multi_pv))
            else:
                logger.warning('Error setting maximum MultiPV.')

    def quit(self):
        """
            Quit the engine
        """
        self.engine.quit()


def read_all_pgn(filename):
    """Read all the games of a PGN file
    Args:
        filename (str) Name of the PGN file
    Returns:
        all_games (list[chess.game]) List with all the games
    """
    logger.info(' Reading PGN file {} '.format(filename).
                center(80, '*'))
    all_games = []
    game_ok = True
    t0 = time.time()
    with open(filename, 'r') as pgn_file:
        while game_ok:
            new_game = chess.pgn.read_game(pgn_file)
            if new_game:
                all_games.append(new_game)
            else:
                game_ok = False
    t1 = time.time()
    logger.info('Total number of games: {}'.format(len(all_games)))
    logger.info('Time: {:.2f} seconds'.format(t1 - t0))
    logger.info(40 * '-')

    return all_games


def find_player(pgn_games, name):
    """
    Find a player in a pgn file using regular expressions.
    Args:
        pgn_games   (list[chess.game]) list of pgn games to parse
        name        (str) Name or part of the name of the player
    Returns:
        If there are several matches, the list of coincidences
        If there is only one match, the name and the list of matches
    """
    logger.info('Searching for players matching: "{}"'.format(name))
    all_found = []
    all_games = []
    for game in pgn_games:
        if re.search(name, game.headers['White'], flags=re.IGNORECASE):
            all_found.append(game.headers['White'])
            all_games.append(game)
        if re.search(name, game.headers['Black'], flags=re.IGNORECASE):
            all_found.append(game.headers['Black'])
            all_games.append(game)
    unique_players = list(set(all_found))
    if len(unique_players) > 1:
        logger.info('Several players found:')
        for name in unique_players:
            logger.info('\t{}'.format(name))
        sys.exit(3)
    elif len(unique_players) == 1:
        logger.info('Player found:\n\t{}'.format(unique_players[0]))
        unique_players = unique_players[0]
        # player = player(name_found[0])
    else:
        logger.info('No player found.')
    logger.info(40 * '-')

    return unique_players, all_games


def move_evaluation_position(pv_list, move):
    """
    Get in what position in the engine analysis is the move.
    Args:
        pv_list (chess.uci.InfoHandler.info): dictionary with the information
                                              of the analysis
        move (node.move.uci()): Move to find
    Returns:
        evaluation ((pos, cp)): Tuple with position in list and cp value
    """
    for i in pv_list['pv'].keys():
        if move == str(pv_list['pv'][i][0]):
            return (i, pv_list['score'][i][0])


def analyze_game(game, machine, ply=None, tpm=None, player=None):
    """
        Analyze a game
        Args:
            game (): Game of the player to analyze read from the PGN file
            machine (Engine): Engine to analyze the game
            ply (int): Depths of analysis
            tpm (int): Time per move
            player (str): Name of the player to analyze
        Returns:
            analyzed_game (list[csv_move]): Game analyzed
    """
    white_score = []
    black_score = []
    white_cp_diff = []
    black_cp_diff = []
    analyzed_game = {'white': white_score,
                     'black': black_score
                    }
    # Board
    board = chess.Board()
    stats = chess.uci.InfoHandler()
    # Engine
    machine.engine.ucinewgame()
    machine.engine.info_handlers.append(stats)
    # Analyze moves
    node = game
    while not node.is_end():
        # Analyze current move
        machine.engine.position(board)
        best_move = machine.engine.go(movetime=tpm,depth=ply)
        # Info
        for k,v in stats.info['pv'].iteritems():
            logger.debug('{:12} {:5} {:5}'.\
                         format(board.variation_san([v[0]]),
                                stats.info['score'][k].cp,
                                stats.info['score'][k].mate))
        # Push next move to the board
        node = node.variation(0)
        move_pos, move_cp = move_evaluation_position(stats.info,
                                                     node.move.uci())
        bm_move = stats.info['pv'][1][0].uci()
        bm_cp = stats.info['score'][1][0]
        # Normalize
        move_cp /= 100
        bm_cp /= 100
        logger.debug('bm:{:4} cp={:<5} mv:{:4} cp={:<5} pos={:<3}'.\
                     format(bm_move,
                            bm_cp,
                            node.move.uci(),
                            move_cp, move_pos))
        # Move - Best move - score - cp difference
        cp_diff = bm_cp - move_cp

        #Store the results
        data_move = Move(node.san(),
                         move_cp,
                         board.variation_san([stats.info['pv'][1][0]]),
                         bm_cp,
                         move_pos
                        )
        board = node.board()
        if not board.turn:
            white_score.append(data_move)
        else:
            black_score.append(data_move)
        logger.debug('Next move done: {:5}\n'.format(node.san())+40*'-')
    # Check that white and black have the same number of moves
    if len(analyzed_game['white']) > len(analyzed_game['black']):
        analyzed_game['black'].append(Move())
        black_cp_diff.append(0)

    print_analyzed_game(analyzed_game)

    return analyzed_game


def average_analyzed_game(player_game):
    """
    Calculate the averate for player's game
    Args:
        game (analyzed_game) : Game already analyzed for one player
                               (black or white)
    Returns:
        cp_avg    (int)   : Average of cp for white
        diff_avg  (int)   : Average difference with best move for white
        pos_list  (dict)  : Dictionary with the number of times that the move
                            was in that position of the best move
    """
    avg_str = 'cp avg: {} diff avg: {}'
    cp_diff = []
    cp = []
    pos_dict = {}
    for i in player_game:
        if not i.move is None:
            cp_diff.append(int(i.cp_diff))
            cp.append(int(i.cp))
            if not i.best_move_position == 0:
                if not i.best_move_position in pos_dict.keys():
                    pos_dict[i.best_move_position] = 1
                else:
                    pos_dict[i.best_move_position] +=1
    total_moves = float(len(cp_diff))
    avg_diff = sum(cp_diff) / total_moves
    avg_cp = sum(cp) / total_moves

    return avg_cp, avg_diff, pos_dict


def analyze_pv_frecuency(pv_dict):
    """
    Get % of matches between the engine and the player
    Args:
        pv_dict (dict)  Dictionary with the frecuencies
    Returns:

    """
    total_moves = 0
    for i, v in pv_dict.iteritems():
        total_moves += v
    # Percentage of 1st move
    first = pv_dict[1] / float(total_moves) * 100
    # Percentage of 2nd move
    second = pv_dict[2] / float(total_moves) * 100
    # Percentage of 3rd move
    third = pv_dict[3] / float(total_moves) * 100
    # First 3
    sum_top_3 = pv_dict[1] + pv_dict[2] + pv_dict[3]
    top_3 = sum_top_3 / float(total_moves) * 100
    result_str = '1st: {:3}({:.2f}%)\n'.format(pv_dict[1], first)
    result_str += '2nd: {:3}({:.2f}%)\n'.format(pv_dict[2], second)
    result_str += '3rd: {:3}({:.2f}%)\n'.format(pv_dict[3], third)
    result_str += 'Top 3: {:3}({:.2f}%)'.format(sum_top_3, top_3)

    print result_str


def print_analyzed_game(game):
    """
    Print an analyzed game
    Args:
        game (analyzed_game) : Game already analyzed
    Returns:
        Printout with verbose or debug:
          <mv #>. <mv> {<mv #>. <bm> cp=<cp> diff=<diff> pos=<pos>} - [[same for black]]
        With normal level only:
          White: avg cp <avg_cp> avg diff <avg_diff>
          <pos_dict>
          Black: avg cp <avg_cp> avg diff <avg_diff>
          <pos_dict>
    """
    for i in range(len(game['white'])):
        # Move number. white - black
        logger.debug('{:3}. {} - {}'.\
                     format(i+1,
                            game['white'][i],
                            game['black'][i]
                           )
                    )
    avg_cp, avg_diff, pos = average_analyzed_game(game['white'])
    analyze_pv_frecuency(pos)
    logger.info('White: avg cp {:.2f} avg diff {:.2f}'.\
                format(avg_cp, avg_diff))
    avg_cp, avg_diff, pos = average_analyzed_game(game['black'])
    logger.info('Black: avg cp {:.2f} avg diff {:.2f}'.\
                format(avg_cp, avg_diff))


#-------------------------------------------------------------------------------
#  /\  _ _     _ _  _  _ _|_ _   _  _  _|   _ _  _ . _
# /~~\| (_||_|| | |(/_| | | _\  (_|| |(_|  | | |(_||| |
#        _|
#-------------------------------------------------------------------------------

def arguments():
    """
    Parse the arguments of the script.
    :returns args: Arguments for the program
    :rtype: Namespace parse_args
    """
    parser = argparse.ArgumentParser(description=__doc__,
                        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('--version', action='version', version=__version__)
    parser.add_argument('pgn_file',
                        action='store',
                        help='PGN file with the games to analyze.')
    parser.add_argument('-v', '--verbose',
                        action='store_true',
                        help='Activate verbosity')
    parser.add_argument('--debug',
                        type=str,
                        action='store',
                        help='Activate debug logging to file')
    parser.add_argument('-e', '--engine',
                        action='store',
                        type=str,
                        help='Chess engine to use for the analysis.')
    parser.add_argument('-p', '--player',
                        action='store',
                        type=str,
                        help='Name of the player to analyze.')
    parser.add_argument('-t', '--time',
                        action='store',
                        type=int,
                        default=1000,
                        help='Time per move for the engine. '
                             'Default: 1000 micro-seconds')
    args = parser.parse_args()

    return args


def logging_init(verbose, debug_file):
    """Configure the logging levels based in the arguments of the script

    :arg verbose: Activate the verbosity of the logs
    :varg verbose: boolean
    :arg debug_file: Write debug information to a file
    :varg debug_file: str
    """
    file_fmt = '%(asctime)s.%(msecs)03d - %(levelname)-8s - %(name)-s - %(message)s'
    console_fmt = '%(message)s'
    # Default logger
    console_handler = logging.StreamHandler()
    console_formatter = logging.Formatter(console_fmt)
    console_handler.setFormatter(console_formatter)
    logger.addHandler(console_handler)
    logger.setLevel(logging.INFO)

    if debug_file is not None:
        # Logging to a file
        file_handler = FileHandler(debug_file)
        file_formatter = logging.Formatter(file_fmt, datefmt='%Y-%m-%d %H:%M:%S')
        file_handler.setFormatter(file_formatter)
        logger.addHandler(file_handler)
        file_handler.setLevel(logging.DEBUG)
    if verbose:
        # Increase the logging level to DEBUG
        logger.setLevel(logging.DEBUG)


def main():
    """"
        1. Arguments and logging
        2. Read all teh games
        3. Find player and his/her games
        4. Create chess engine
        5. Analysis begin
    """
    # 1. Arguments and logging
    args = arguments()
    logging_init(args.verbose, args.debug)

    # 2. Read all the games
    all_analyzed_games = []
    all_games = read_all_pgn(args.pgn_file)

    # 3. Find player and his/her games
    if args.player is not None:
        player_name, games_to_analyze = find_player(all_games, args.player)
    else:
        player_name = 'All'
        games_to_analyze = all_games

    # 4. Create chess engine
    chess_engine = Engine(args.engine)

    # 5. Analysis begin
    game_number = 1
    t0 = time.time()
    for game in games_to_analyze:
        logger.info(20*'-')
        logger.info('Analyzing game {} of {}'.format(game_number, len(games_to_analyze)))
        analyzed_game = analyze_game(game, chess_engine, tpm=args.time)
        game_number += 1
        #sys.exit()
    logger.info(40*'-')
    t1 = time.time()
    logger.info('Time: {:.2f} seconds'.format(t1 - t0))


################################################################################
#         __  __       _
#        |  \/  | __ _(_)_ __
#        | |\/| |/ _` | | '_ \
#        | |  | | (_| | | | | |
#        |_|  |_|\__,_|_|_| |_|
#
################################################################################
if __name__ == "__main__":
    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)
    sys.tracebacklimit = 0
    if sys.version_info < (2, 7):
        print "Python 2.7 or higher required"
        sys.exit(9)
    # General logger
    logger = logging.getLogger(__name__)

    # Main funtion
    try:
        main()
    except KeyboardInterrupt:
        print "\nProgram interrupted by CTRL-C.\n"
        sys.exit()
